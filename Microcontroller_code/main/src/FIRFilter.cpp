#include "Arduino.h"
#include "FIRFilter.h"

// Setup filter coefficients generated by http://t-filter.engineerjs.com/. Low pass filter designed for 20Hz sampling frequency
static float FIRImpulseResponse20[FIRFilterLength20] = {
-0.05406843003306215,
-0.012879687544701991,
0.3239913853004301,
0.5707233139958573,
0.3239913853004301,
-0.012879687544701991,
-0.05406843003306215
};

// Setup filter coefficients generated by http://t-filter.engineerjs.com/. Low pass filter designed for 50Hz sampling frequency
static float FIRImpulseResponse50[FIRFilterLength50] = {
-0.009881430542859957,
-0.054323909697552894,
-0.045282705199950646,
0.15634140721815556,
0.4200595778757181,
0.4200595778757181,
0.15634140721815556,
-0.045282705199950646,
-0.054323909697552894,
-0.009881430542859957 
};

// Initialise filter
void FIRFilterInit20(FIRFilter20 *fir) {

  // Clear filter buffer
  for (uint8_t i = 0; i < FIRFilterLength20; i++) {
    fir->buf[i] = (float)0.0;
  }

  // Reset buffer index
  fir->bufIndex = (uint8_t)0;

  // Clear filter output
  fir->output = (float)0.0;
}

void FIRFilterInit50(FIRFilter50 *fir) {

  // Clear filter buffer
  for (uint8_t i = 0; i < FIRFilterLength50; i++) {
    fir->buf[i] = (float)0.0;
  }

  // Reset buffer index
  fir->bufIndex = (uint8_t)0;

  // Clear filter output
  fir->output = (float)0.0;
}

/* 20 Hz Sampling low pass filter */
float FIRFilterUpdate20(FIRFilter20 *fir, float input) {

  // Input the new value into the buffer
  fir->buf[fir->bufIndex] = input;

  // Increment the buffer index
  fir->bufIndex++;

  // If the buffer index is out of range, reset it
  if (fir->bufIndex == FIRFilterLength20) {
    fir->bufIndex = 0;
  }

  fir->output = (float)0.0;

  uint8_t sumIndex = fir->bufIndex;

  for (uint8_t i = 0; i < FIRFilterLength20; i++) {
    if (sumIndex > 0) {
      sumIndex--;
    } else {
      sumIndex = FIRFilterLength20 - 1;
    }

    // Multiply impulse response with shifted input sample and add it to output
    fir->output += FIRImpulseResponse20[i] * fir->buf[sumIndex];
  }

  // Return filtered output
  return fir->output;
}

/* 50 Hz Sampling low pass filter */
float FIRFilterUpdate50(FIRFilter50 *fir, float input) {

  // Input the new value into the buffer
  fir->buf[fir->bufIndex] = input;

  // Increment the buffer index
  fir->bufIndex++;

  // If the buffer index is out of range, reset it
  if (fir->bufIndex == FIRFilterLength50) {
    fir->bufIndex = 0;
  }

  fir->output = (float)0.0;

  uint8_t sumIndex = fir->bufIndex;

  for (uint8_t i = 0; i < FIRFilterLength50; i++) {
    if (sumIndex > 0) {
      sumIndex--;
    } else {
      sumIndex = FIRFilterLength50 - 1;
    }

    // Multiply impulse response with shifted input sample and add it to output
    fir->output += FIRImpulseResponse50[i] * fir->buf[sumIndex];
  }

  // Return filtered output
  return fir->output;
}